import { createContext, useContext, useMemo } from "react";
import { useQueryClient } from '@tanstack/react-query';
import usePartySocket from "partysocket/react";
import { RealtimeMessage, ThreadEvent, ThreadEventSchema } from "@/app/schemas/realtime";
import { orpc } from "@/lib/orpc";

type ThreadRealtimeContextValue = {
    send: (event: ThreadEvent) => void;
}

interface ThreadRealtimeProviderProps {
    children: React.ReactNode;
    threadId: string;
}
const ThreadRealtimeContext = createContext<ThreadRealtimeContextValue | null>(null);

export function ThreadRealtimeProvider({children, threadId}: ThreadRealtimeProviderProps){
    const QueryClient=useQueryClient();
    type ThreadListOptions= ReturnType<typeof orpc.message.thread.list.queryOptions>;
    type ThreadQueryData= Awaited<ReturnType<ThreadListOptions["queryFn"]>>;
    const socket = usePartySocket({
        host:"https://nexflow-realtime.gauravkumar803109.workers.dev",
        room:`thread-${threadId}`,
        party:"chat",
        onMessage(e){
            try{
                const parsed=JSON.parse(e.data);
                const result=ThreadEventSchema.safeParse(parsed);
                if(!result.success){
                    console.log("Invalid thread message received");
                    return;
                }
                const evt=result.data;

                if(evt.type==="thread:reply:created"){
                    const replyObj=evt.payload.reply as RealtimeMessage;
                    //use the same key generated by orpc
                    const listOptions=orpc.message.thread.list.queryOptions({
                        input:{
                            messageId:threadId,
                        }
                    });
                    QueryClient.setQueryData<ThreadQueryData>(listOptions.queryKey, (old)=>{
                        if(!old) return old;
                        const reply={
                            reactions:Array.isArray(replyObj.reactions)?replyObj.reactions:[],
                            ...replyObj,
                        } as ThreadQueryData["messages"][number];
                        return{
                            ...old,
                            messages:[reply, ...old.messages],
                        }
                    })
                }
                if(evt.type==="thread:reply:updated"){
                    const {messageId, reactions, threadId:tId}=evt.payload;
                    if(tId!==threadId) return;
                    const listOptions=orpc.message.thread.list.queryOptions({
                        input:{
                            messageId:threadId,
                        }
                    });
                    QueryClient.setQueryData<ThreadQueryData>(listOptions.queryKey, (old)=>{
                        if(!old) return old;
                        if(messageId === threadId){
                            return{
                                ...old,
                                parent:{
                                    ...old.parent,
                                    reactions: reactions,
                                },
                            }
                        }
                        return{
                            ...old,
                            messages: old.messages.map((msg)=> msg.id === messageId ? {
                                ...msg,
                                reactions: reactions,
                            } : msg),
                        }
                    });
                    return;
                }


            }catch{
                console.log("Failed to parse thread message:", e.data);
            }
        }
        
    });

    const value=useMemo<ThreadRealtimeContextValue>(()=>{
        return{
            send:(event)=>{
                socket.send(JSON.stringify(event));
            }
        }
    }, [socket]);

    return (
        <ThreadRealtimeContext.Provider value={value}>
            {children}
        </ThreadRealtimeContext.Provider>
    );
}

export function useThreadRealtime(){
    const ctx = useContext(ThreadRealtimeContext);
    if (!ctx) {
        throw new Error("useThreadRealtime must be used within a ThreadRealtimeProvider");
    }
    return ctx;
}

export function useOptionalThreadRealtime(): ThreadRealtimeContextValue | null {
    return useContext(ThreadRealtimeContext);
}